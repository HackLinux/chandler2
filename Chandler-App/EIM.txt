----------------------
The Sharing Record API
----------------------


>>> from chandler import eim
>>> from decimal import Decimal


Record Types and Fields
=======================

Record types are defined by subclassing ``eim.Record`` and creating
``eim.key`` and ``eim.field`` attributes to describe their layout::

    >>> Text500 = eim.TextType(size=500)
    >>> class Demo(eim.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     itemNumber  = eim.key(int)
    ...     itemName    = eim.field(eim.TextType(size=50))
    ...     description = eim.field(Text500)
    ...     price       = eim.field(eim.DecimalType(None, 6, 2), u"Price", str)

    >>> r1 = Demo(1,"Foo", "This is a foo", Decimal('2.50'))

    >>> r1
    Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

    >>> Demo(1, eim.NoChange, eim.NoChange, eim.NoChange)
    NoChange

Each record type can have an (optional) unique URI, that can be looked up using
the ``eim.lookupSchemaURI()`` API:

    >>> eim.lookupSchemaURI('cid:eim.test.demo-record@osaf.us')
    <class 'Demo'>

But each record type must have a *unique* URI; duplicating the URI is an
error::

    >>> class Wrong(eim.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'    # same as before
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:eim.test.demo-record@osaf.us' is already in use


Creating diffs from records::

    >>> r1 - r1     # no change between these records
    NoChange

    >>> r1 - 123
    Traceback (most recent call last):
      ...
    TypeError: 123 is not a Demo record

    >>> r1 - Demo(2, "baz", "spam", Decimal('1.29'))
    Traceback (most recent call last):
      ...
    ValueError: Can't subtract itemNumber 2 from itemNumber 1

    >>> r1 - Demo(1, "Bar", "This is a foo", Decimal('1.29'))
    Demo(1, u'Foo', NoChange, Decimal("2.50"))

    >>> r1 - Demo(1, "Foo", "This is NOT a foo", Decimal('2.50'))
    Demo(1, NoChange, u'This is a foo', NoChange)

    >>> r1 - Demo(1, "Foo", eim.NoChange, Decimal('2.50'))
    Demo(1, NoChange, u'This is a foo', NoChange)

Record addition (second record overwrites fields in first, unless NoChange,
as long as keys match)::

    >>> diff1 = Demo(1, "Bar", eim.NoChange, Decimal('1.29'))
    >>> diff2 = Demo(1, eim.NoChange, "This is NOT a foo", Decimal('2.50'))

    >>> r1 + diff1
    Demo(1, u'Bar', u'This is a foo', Decimal("1.29"))

    >>> r1 + Demo(2, "spam", "wah", eim.NoChange)
    Traceback (most recent call last):
      ...
    ValueError: Can't add itemNumber 1 to itemNumber 2

You can get a unique key for a record using its ``getKey()`` method.  The
return value is a tuple containing the record type, followed by the values of
the record's key fields, in the order they were defined::

    >>> diff1.getKey()
    (<class 'Demo'>, 1)

    >>> class Demo2(eim.Record):
    ...     URI         = 'cid:eim.Demo2@osaf.us'
    ...     itemName    = eim.field(eim.TextType(size=50))
    ...     itemNumber  = eim.key(int)
    ...     description = eim.field(eim.TextType(size=500))
    ...     price       = eim.key(eim.DecimalType(None, 6, 2))

    >>> Demo2(u'blah', 27, u'foobly', Decimal('16.2')).getKey()
    (<class 'Demo2'>, 27, Decimal("16.2"))

Records also have an ``explain()`` method that yields tuples describing their
(non-key, non-``NoChange``) contents::

    >>> sorted(r1.explain()) # doctest: +NORMALIZE_WHITESPACE
    [(u'Price', '2.50', Demo(1, NoChange, NoChange, Decimal("2.50"))),
     ('description', u'This is a foo', Demo(1, NoChange, u'This is a foo', NoChange)),
     ('itemName', u'Foo', Demo(1, u'Foo', NoChange, NoChange))]

    >>> sorted(Demo(2, eim.NoChange, "wah", eim.NoChange).explain())
    [('description', u'wah', Demo(2, NoChange, u'wah', NoChange))]

Notice that the unicode string "Price" and its associated value were generated
using the unicode title and formatter that were registered with the price field
when it was created.  You can also explicitly register formatters for specific
fields or field types, and they will be used to "explain" the item::

    >>> @eim.format_field.when_object(Demo.itemName)
    ... def format_itemName(field, value):
    ...     return "%s (%s)" % (value, field.name)

    >>> @eim.format_field.when_object(Text500)
    ... def format_Text500(field, value):
    ...     return "This text can be a maximum of 500 bytes in UTF-8"

    >>> sorted(r1.explain()) # doctest: +NORMALIZE_WHITESPACE
    [(u'Price', '2.50', Demo(1, NoChange, NoChange, Decimal("2.50"))),
     ('description', 'This text can be a maximum of 500 bytes in UTF-8',
       Demo(1, NoChange, u'This is a foo', NoChange)),
     ('itemName', u'Foo (itemName)', Demo(1, u'Foo', NoChange, NoChange))]

If you do not register a title with a field when you create it, the field's
name is used instead.  If there is no formatter registered for the specific
field or its typeinfo, field's raw value is used unchanged.

There is also a ``global_formatters`` dictionary, which is used to format
special values that can occur in any field.  Here, we'll use it to format
``Decimal("2.50")`` as ``$2.50``::

    >>> eim.global_formatters[Decimal("2.50")] = lambda f, v: "$%s" % v

    >>> sorted(r1.explain()) # doctest: +NORMALIZE_WHITESPACE
    [(u'Price', '$2.50', Demo(1, NoChange, NoChange, Decimal("2.50"))),
     ('description', 'This text can be a maximum of 500 bytes in UTF-8',
       Demo(1, NoChange, u'This is a foo', NoChange)),
     ('itemName', u'Foo (itemName)', Demo(1, u'Foo', NoChange, NoChange))]

    >>> del eim.global_formatters[Decimal("2.50")]


Extending Existing Record Types
-------------------------------

If you are adding new fields to a record type that has previously been used
to dump records, you must always add them *after* any existing fields, and
give them default values::

    >>> class Demo3(eim.Record):
    ...     URI         = 'cid:eim.Demo3@osaf.us'
    ...     itemName    = eim.field(eim.TextType(size=50))
    ...     itemNumber  = eim.key(int)
    ...     description = eim.field(eim.TextType(size=500))
    ...     price       = eim.field(
    ...         eim.DecimalType(None, 6, 2), default=Decimal('49.99')
    ...     )
    >>> Demo3('test', 27, 'blah').price
    Decimal("49.99")

Note that you can't specify any optional fields (i.e., ones with default
values) before required ones::

    >>> class Demo4(eim.Record):
    ...     URI         = 'cid:eim.Demo4@osaf.us'
    ...     itemName    = eim.field(eim.TextType(size=50))
    ...     itemNumber  = eim.key(int)
    ...     description = eim.field(eim.TextType(size=500), default="blah")
    ...     price       = eim.field(eim.DecimalType(None, 6, 2))
    Traceback (most recent call last):
      ...
    TypeError: Can't have required fields after optional ones: Demo4.price


Record Sets
-----------

    >>> class R(eim.Record):
    ...     URI = 'cid:eim.R@osaf.us'
    ...     k = eim.key(int)
    ...     v = eim.field(int)

    >>> r1 = R(1, 2)
    >>> r2 = R(1, -2)
    >>> r3 = R(3, 3)

    >>> rs = eim.RecordSet([r1])

    >>> bool(rs)
    True

    >>> bool(eim.RecordSet())
    False

    >>> bool(eim.Diff([],[r1]))
    True

    >>> rs.inclusions == set([r1])
    True
    >>> rs.exclusions == set()
    True

    >>> rs == eim.RecordSet([r2])
    False
    >>> rs != eim.RecordSet([r2])
    True
    >>> rs == eim.RecordSet([r1])
    True
    >>> rs != eim.RecordSet([r1])
    False

    >>> rs - rs
    Diff(set([]), set([]))

    >>> rs+eim.RecordSet([r3]) == eim.Diff([r1,r3], [])
    True
    >>> rs-eim.RecordSet([r3]) == eim.Diff([r1],[r3])
    True

    >>> rs+eim.RecordSet([r2]) == eim.RecordSet([r2])
    True

    >>> eim.RecordSet([r2]) + rs == rs
    True

    >>> rs - eim.RecordSet([r2]) == rs
    True

    >>> rs_old = rs
    >>> rs += eim.RecordSet([r2])
    >>> rs == eim.RecordSet([r2])
    True

    >>> rs is rs_old
    True

    >>> eim.Diff([eim.NoChange], [eim.NoChange])
    Diff(set([]), set([]))
    

Extracting Nonconflicting Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The "bitwise OR" operator (|) produces the nonconflicting merge of two diff
records.  For each field in the original records, the new record contains
either the value shared by both of the original records, or else
``eim.NoChange`` if the values conflicted.  If one of the original records
has a value of ``eim.NoChange`` in a given field, the other record's value
for that field is used.

This allows you to compute the nonconflicting subset of two sets of changes to
a record::

    >>> class S(eim.Record):
    ...     URI = 'cid:eim.S@osaf.us'
    ...     f1 = eim.field(int)
    ...     f2 = eim.field(int)

    >>> S(1, 2) |  S(1, eim.NoChange)
    S(1, 2)

    >>> S(eim.NoChange, 12) | S(16, eim.NoChange)
    S(16, 12)

    >>> S(1,2) | S(1,3)
    S(1, NoChange)

    >>> S(1,2) | S(3,4)
    NoChange

    >>> R(1,2) | R(1,3)     # first field is a key
    NoChange

The bitwise OR operator can also be applied to diffs::

    >>> eim.Diff([R(1,2)]) | eim.Diff([R(1,2)])
    Diff(set([R(1, 2)]), set([]))

    >>> eim.Diff([R(1,3)]) | eim.Diff([R(1,2)])
    Diff(set([]), set([]))

    >>> eim.Diff([R(1,3)]) | eim.Diff([R(1,2), R(1,3), R(1,4)])
    Diff(set([]), set([]))


Subset Removal
~~~~~~~~~~~~~~

The conflict resolution API needs to be able to remove changes from a diff,
both to discard pending changes and to break down a pending change diff
into its constituent changes.  The diff ``.remove()`` method allows you to
delete an arbitrary subset of an existing recordset::

    >>> d = eim.Diff([R(1,2)], [R(2,3)])
    >>> d.remove(eim.Diff([], [R(2,3)]))  # delete the exclusion
    >>> d
    Diff(set([R(1, 2)]), set([]))
    
    >>> d.remove(eim.Diff([R(1,2)]))
    >>> d
    Diff(set([]), set([]))

Removing non-existent inclusions raises a KeyError::

    >>> d.remove(eim.Diff([R(2,4)]))
    Traceback (most recent call last):
      ...
    KeyError: R(2, 4)

    >>> r = Demo(1,"Foo", "This is a foo", Decimal('2.50'))
    >>> d = eim.Diff([r])

You can also remove individual Records, without having to wrap them in a
recordset::

    >>> d.remove(Demo(1,"Foo", eim.NoChange, eim.NoChange))
    >>> d
    Diff(set([Demo(1, NoChange, u'This is a foo', Decimal("2.50"))]), set([]))
    >>> d.remove(Demo(1, eim.NoChange, 'This is a foo', eim.NoChange))
    >>> d
    Diff(set([Demo(1, NoChange, NoChange, Decimal("2.50"))]), set([]))
    

Filters
-------

Filters are used to suppress the inclusion of selected fields from shared
records.  To define one, you must provide a unique URI, and a human-readable
description (in Unicode) of the filter::

    >>> Reminders = eim.Filter('cid:reminder-filter@osaf.us', u"Reminders")
    >>> Passwords = eim.Filter('cid:password-filter@osaf.us', u"Passwords")

    >>> eim.lookupSchemaURI('cid:reminder-filter@osaf.us')
    Filter('cid:reminder-filter@osaf.us', u'Reminders')

    >>> eim.lookupSchemaURI('cid:password-filter@osaf.us')
    Filter('cid:password-filter@osaf.us', u'Passwords')


When you define record types, you can provide a list of filters to one or more
fields::

    >>> t50 = eim.TextType(size=50)
    >>> d62 = eim.DecimalType(None, 6, 2)
    >>> t500 = eim.TextType(size=500)

    >>> class SomeType(eim.Record):
    ...     URI = 'cid:SomeType-for-eim@osaf.us'
    ...     foo = eim.key(int)
    ...     bar = eim.field(t50, filters=[Reminders, Passwords])
    ...     baz = eim.field(d62, filters=[Reminders])
    ...     spam  = eim.field(t500)
    ...     pin = eim.field(int, filters=[Passwords])

These fields are then suppressed whenever you take the ``sync_filter()`` of an
applicable record::

    >>> r4 = SomeType(42, u'password reminder', Decimal('3'), u'blah', 2001)
    >>> r4
    SomeType(42, u'password reminder', Decimal("3"), u'blah', 2001)

    >>> Reminders.sync_filter(r4)   # remove other fields
    SomeType(42, NoChange, NoChange, u'blah', 2001)

    >>> Passwords.sync_filter(r4)   # remove Password fields
    SomeType(42, NoChange, Decimal("3"), u'blah', NoChange)

Record types that are not linked to the filter are returned unchanged from
``sync_filter()``::

    >>> Reminders.sync_filter(r1)
    R(1, 2)

    >>> Passwords.sync_filter(r3)
    R(3, 3)

You can also pass ``RecordSet`` or ``Diff`` instances to ``sync_filter``, and
the result is a new ``RecordSet`` or ``Diff``::

    >>> r4s = eim.RecordSet([r4])
    >>> Passwords.sync_filter(r4s)  # doctest: +NORMALIZE_WHITESPACE
    RecordSet(set([SomeType(42, NoChange, Decimal("3"), u'blah', NoChange)]))

But only the ``inclusions`` are filtered, not the ``exclusions``::

    >>> r4s = eim.Diff(exclusions=[r4])
    >>> Passwords.sync_filter(r4s)  # doctest: +NORMALIZE_WHITESPACE
    Diff(set([]),
              set([SomeType(42, u'password reminder', Decimal("3"), u'blah',
                   2001)]))

Filter Arithmetic
-----------------

You can add fields to an existing filter using the ``+=`` operator::

    >>> Reminders.sync_filter(r1)
    R(1, 2)

    >>> Reminders += R.v

    >>> Reminders.sync_filter(r1)
    NoChange

You can also combined filters using ``+=``.  Normally this will be used by
sharing conduits to construct filters according to the share's filtering
options::

    >>> conduit_filter = eim.Filter(None, u'Temporary filter')
    >>> conduit_filter += Reminders     # add in active filters for this share
    >>> conduit_filter += Passwords     # (real code would use lookupSchemaURI)

    >>> conduit_filter.sync_filter(r1)
    NoChange

    >>> conduit_filter.sync_filter(r4)
    SomeType(42, NoChange, NoChange, u'blah', NoChange)


Notes on Filtering and Sync algorithms::

    Note: We may need a publish_filter() capability if Cosmo can't handle
          missing fields

    for item in changed_items:
        rsNewBase[item.itsUUID] = Recordset(translator.exportItem(item))

    for itemUUID, rs in inbound_diff.items():
        dInbound = rs - rsOldBase.setdefault(itemUUID, empty_rs)    # Cosmo 0.6
        if itemUUID in rsNewBase:
            dLocal = rsNewBase[itemUUID] - rsOldBase[itemUUID]
            dLost[itemUUID] = dLocal - dInbound
            rsNewBase[itemUUID] += dInbound
        translator.processRecords(sync_filter(dInbound)) #import and/or delete
        rsOldBase[itemUUID] += dInbound

    for itemUUID, rs in rsNewBase.items():
        if itemUUID in rsOldBase:
            dOutbound = sync_filter(rs - rsOldBase[itemUUID])
        else:
            dOutbound = publish_filter(rs)
            rsOldBase[itemUUID] = empty_rs
        #send(dOutbound)
        rsOldBase[itemUUID] += dOutbound
        send(rsOldBase[itemUUID])   # Cosmo 0.6


The Translator Framework
========================

A ``eim.Translator`` is an object that handles importing and exporting of
Chandler items as EIM records.  It must have ``URI`` (string), ``version``
(integer), and ``description`` (unicode) attributes::

    >>> from chandler.core import Item, Extension, inherited_attrs
    >>> class DemoTranslator(eim.Translator):
    ...     """Demonstration translator"""
    ...     URI = "cid:demotranslator@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @Demo.importer
    ...     def import_Demo_record(self, r):
    ...         print "importing Demo record:", r
    ...
    ...     @Demo.deleter
    ...     def delete_Demo_record(self, r):
    ...         print "deleting Demo:", r
    ...
    ...     @R.importer
    ...     def import_R_record(self, r):
    ...         print "importing R record:", r
    ...
    ...     @R.deleter
    ...     def delete_R_record(self, r):
    ...         print "deleting R:", r
    ...
    ...     @eim.exporter(Item)
    ...     def export_item(self, item):
    ...         print "exporting item"
    ...         yield R(1,2)

When we support user-defined translator classes, we will probably need to use
either "entry points" or some repository registry to look them up for
importing.  However, once imported, translator classes can be looked up using
the standard ``lookupSchemaURI()`` API::

    >>> eim.lookupSchemaURI("cid:demotranslator@osaf.us")
    <class 'DemoTranslator'>
    >>> t = DemoTranslator()


Exporting (Sharing Layer)
-------------------------

The sharing layer calls a translator instance's  ``startExport()`` and
``finishExport()`` methods at the beginning and end of an export operation.
The default implementations do nothing, although they can be overridden in
subclasses.  ``finishExport()`` must yield or return a (possibly-empty)
sequence of records, while the return value of ``startExport()``, if any,
is ignored.

In between the two calls, ``exportItem()`` can be called zero or more times
to yield EIM records for a given item:

    >>> t = DemoTranslator()
    >>> t.startExport()

    >>> item = Item(title="foo")
    >>> list(t.exportItem(item))
    exporting item
    [R(1, 2)]

    >>> list(t.finishExport())
    []


Importing (Sharing Layer)
-------------------------

The sharing layer calls a translator instance's  ``startImport()`` and
``finishImport()`` methods at the beginning and end of an import operation.
The default implementations do nothing, although they can be overridden in
subclasses.  The return values, if any, are ignored.

In between the two calls, ``importRecords()`` can be called zero or more times
to process a ``RecordSet`` object's inclusions (adds/updates) and exclusions
(deletions), or ``importRecord()`` can be called zero or more times to process
a single ``Record`` object.

    >>> t = DemoTranslator()
    >>> t.startImport()

    >>> d = Demo(1,"Foo", "This is a foo", Decimal('2.50'))

    >>> t.importRecord(R(1,2))
    importing R record: R(1, 2)

    >>> t.importRecords(eim.Diff([R(1,2)], [d]))
    importing R record: R(1, 2)
    deleting Demo: Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

    >>> t.importRecords(eim.Diff([d], [R(1,2)]))
    importing Demo record: Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))
    deleting R: R(1, 2)

    >>> t.finishImport()


Translator Inheritance
----------------------

Importers, deleters, and exporters are inherited by translator subclasses, and
stamp classes can be used as export targets::

    >>> class DemoExtension(Extension):
    ...     inherited_attrs(data="initial data")

    >>> class DemoTranslator2(DemoTranslator):
    ...     """Demonstration translator 2"""
    ...     URI = "cid:demotranslator2@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @Demo.importer
    ...     def import_Demo_record(self, r):
    ...         print "welcome,", r
    ...
    ...     @Demo.deleter
    ...     def delete_Demo_record(self, r):
    ...         print "farewell,", r
    ...
    ...     @eim.exporter(Item)
    ...     def export_item(self, item):
    ...         print "exporting item"
    ...         yield R(-1, -2)
    ...
    ...     @eim.exporter(DemoExtension)
    ...     def export_demo_extension(self, extension):
    ...         print "exporting extension"
    ...         yield R(extension.data, 42)

    >>> t = DemoTranslator2()
    >>> t.startImport()

    >>> t.importRecords(eim.Diff([R(1,2)], [d]))
    importing R record: R(1, 2)
    farewell, Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

    >>> t.importRecords(eim.Diff([d], [R(1,2)]))
    welcome, Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))
    deleting R: R(1, 2)

    >>> t.finishImport()

    >>> t.startExport()
    >>> list(t.exportItem(item))
    exporting item
    [R(-1, -2)]

    >>> DemoExtension(item).add(data=99)
    <DemoExtension object at ...>
    >>> list(t.exportItem(item))
    exporting item
    exporting extension
    [R(-1, -2), R(99, 42)]

    >>> list(t.finishExport())
    []


Creating/Updating Items
-----------------------

Importers will usually use the translator's ``withItemForUUID()`` decorator
to create, add extensions to, or retrieve an existing item by uuid.

    >>> class DemoRecord2(eim.Record):
    ...     URI = 'cid:eim.test.demo-record2@osaf.us'
    ...     uuid  = eim.key(eim.UUIDType)

    >>> class DemoRecord3(eim.Record):
    ...     URI = 'cid:eim.test.demo-record3@osaf.us'
    ...     uuid  = eim.key(eim.UUIDType)

    >>> class DemoTranslator3(eim.Translator):
    ...     """Demonstration translator 3"""
    ...     URI = "cid:demotranslator3@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @DemoRecord2.importer
    ...     def import_Demo_record2(self, r):
    ...         self.withItemForUUID(r.uuid, Item)
    ...         print "Imported record2"
    ...
    ...     @DemoRecord3.importer
    ...     def import_Demo_record3(self, r):
    ...         @self.withItemForUUID(r.uuid)
    ...         def do(item):
    ...             print "Imported record3", item

    >>> t3 = DemoTranslator3()
    >>> t3.startImport()

``withItemForUUID()`` can be used either as a decorator, or as a standalone
method, as you can see above.  When called directly, it simply creates or
updates the item::

    >>> uuid = 'ed0277af-18a2-45b1-917d-a55dc75da776'
    >>> t3.importRecord(DemoRecord2(uuid))
    Imported record2
    >>> demo_item = eim.get_item_for_uuid(uuid)
    >>> demo_item
    <chandler.core.Item object at ...>
    >>> eim.EIM(demo_item).uuid
    UUID('ed0277af-18a2-45b1-917d-a55dc75da776')

And when used as a decorator, it calls the decorated function with the item::

    >>> t3.importRecord(DemoRecord3(uuid))
    Imported record3 <chandler.core.Item object at ...>

If an item of the given UUID already exists, it's used, passing in the item::

    >>> @t.withItemForUUID(uuid, title="testme")
    ... def do_it(item): print item is demo_item, item.title
    True testme

If it doesn't exist, a new Item is created::

    >>> uuid1 = '0c7c6c5c-4a04-4d5a-8997-2fcef848c92d'
    >>> @t.withItemForUUID(uuid1, DemoExtension, data="another_test")
    ... def do_it(item): print item, item.data
    <DemoExtension object at ...> another_test

If you specify a ``chandler.core.Extension`` subclass as the item
type, an extension is passed to your callback.  If the item didn't
already have an extension of the given type, it's added for you.

    >>> DemoExtension.installed_on(demo_item)   # before
    False

    >>> @t.withItemForUUID(uuid, DemoExtension)
    ... def do_it(item): print item
    <DemoExtension object at ...>

    >>> DemoExtension.installed_on(demo_item)   # after
    True

Also, you can set attributes on the returned object using keyword
arguments to ``withItemForUUID()``::

    >>> @t.withItemForUUID(uuid1, DemoExtension, data=42)
    ... def do_it(extension): print extension.data
    42

Attributes set to ``eim.NoChange`` are ignored, as this makes it easier to
process "diff" records when importing (no need to check for no-change values)::

    >>> @t.withItemForUUID(uuid1, DemoExtension, data=eim.NoChange)
    ... def do_it(extension): print extension.data  # value is unchanged
    42

Attributes set to ``eim.Inherit`` are set to their initial value::

    >>> @t.withItemForUUID(uuid1, DemoExtension, data=eim.Inherit)
    ... def do_it(extension): print extension.data
    initial data

In order to support recurrence, translators need to be able to handle the
lookup of an UUID from an alias value, and to retrieve an alias from an item.
The default implementation simply uses an item's UUID as its alias::

   >>> an_item = eim.get_item_for_uuid(uuid1)
   >>> t.getAliasForItem(an_item)
   '0c7c6c5c-4a04-4d5a-8997-2fcef848c92d'

   >>> t.getUUIDForAlias('0c7c6c5c-4a04-4d5a-8997-2fcef848c92d')
   '0c7c6c5c-4a04-4d5a-8997-2fcef848c92d'

Import Error Handling
---------------------

When a callback invoked by ``withItemForUUID()`` raises an error, the
translator's ``recordFailure()`` method is invoked with the exception.
The default implementation saves this and re-raises the error at the
end of the importRecord operation, but you can also override it in a
subclass to do something else::

    >>> class DemoTranslator4(eim.Translator):
    ...     """Demonstration translator 4"""
    ...     URI = "cid:demotranslator4@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @DemoRecord2.importer
    ...     def import_Demo_record2(self, r):
    ...         @self.withItemForUUID(r.uuid, Item)
    ...         def do(item):
    ...             raise TypeError("Some kind of problem")
    ...
    ...     def recordFailure(self, failure):
    ...         print failure

    >>> t4 = DemoTranslator4()
    >>> t4.startImport()

    >>> uuid = 'ed0277af-18a2-45b1-917d-a55dc75da776'
    >>> t4.importRecord(DemoRecord2(uuid))
    Some kind of problem

Of course, you should call the ``super()`` of the method if you also want the
standard behavior, which we'll demonstrate here::

    >>> del DemoTranslator4.recordFailure

    >>> t4.importRecord(DemoRecord2(uuid))
    Traceback (most recent call last):
      ...
    TypeError: Some kind of problem


Conflict Management
-------------------

Translators have an ``explainConflicts()`` method that yields information about
a recordset for conflict-resolution purposes::

    >>> sorted( t.explainConflicts(eim.Diff([R(1,2)], [R(3,4)])) ) # doctest: +NORMALIZE_WHITESPACE
    [('Deleted', (<class 'R'>, 3), Diff(set([]), set([R(3, 4)]))),
     ('v',       2,                Diff(set([R(1, 2)]), set([])))]


TODO: field localization for conflict explanations
TODO: foreign key refs/ordering
TODO: rewrite this crazy doctest as a parcel dev tutorial & a sharing reference


Defining and Using Field Types
==============================

Custom Types
------------

The most basic kinds of field types can be created using the ``BytesType``,
``TextType``, ``IntType``, ``DateType``, ``DecimalType``, ``BlobType`` and
``ClobType`` constructors::

    >>> my_date = eim.DateType()
    >>> my_date
    eim.DateType(None)

Types can be given a unique URI, and they can be looked up by it::

    >>> my_text = eim.TextType("cid:some_text_type@osaf.us", size=99)
    >>> my_text
    eim.TextType('cid:some_text_type@osaf.us', 99)

    >>> eim.typeinfo_for("cid:some_text_type@osaf.us")
    eim.TextType('cid:some_text_type@osaf.us', 99)

    >>> my_text.uri
    'cid:some_text_type@osaf.us'

    >>> my_text.size
    99

But only one type can exist for a given URI at a given point in time::

    >>> another_text = eim.TextType("cid:some_text_type@osaf.us", 99)
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:some_text_type@osaf.us' is already in use

    >>> del my_text     # no conflicting definition now
    >>> another_text = eim.TextType("cid:some_text_type@osaf.us", 99)


Type Aliasing
-------------

The ``eim.typedef()`` API lets you register type information for arbitrary
Python objects, so that you can use existing types, kinds, etc. as field types.
For example::

    >>> class my_int(int):
    ...     """This is just a demonstration type"""

    >>> my_int_type = eim.IntType('cid:my_int_ex@osaf.us')
    >>> eim.typedef(my_int, my_int_type)

Now, ``my_int`` can be used directly as a field type in a ``eim.Record``
class, instead of using the ``IntType`` object::

    >>> class DemoRecord(eim.Record):
    ...     URI = 'cid:eim.DemoRecord@osaf.us'
    ...     an_int = eim.field(my_int)

    >>> DemoRecord.an_int.type
    <class 'my_int'>

    >>> DemoRecord.an_int.typeinfo
    eim.IntType('cid:my_int_ex@osaf.us')

You can alias more than one object to the same type, or alias an object to
an already-registered alias::

    >>> class my_int2(int):
    ...     """Another demonstration type"""

    >>> eim.typedef(my_int2, my_int)
    >>> eim.typeinfo_for(my_int2) is eim.typeinfo_for(my_int)
    True

There are also built-in aliases for anonymous versions of the sizeless
primitive types (``IntType``, ``BlobType``, ``ClobType``, and ``DateType``),
so you can use them directly in fields::

    >>> eim.typeinfo_for(eim.IntType)
    eim.IntType(None)

    >>> eim.typeinfo_for(eim.BlobType)
    eim.BlobType(None)

    >>> eim.typeinfo_for(eim.ClobType)
    eim.ClobType(None)

    >>> eim.typeinfo_for(eim.DateType)
    eim.DateType(None)


Type Conversion
---------------

Because there are only six primitive EIM types (bytes, text, integer, decimal,
date/time, and "lob"), it is usually necessary to convert some application-
level data types to the corresponding primitive type.

For example, let's say that an application has a value that is normally
represented as a hexidecimal string, but which for some reason it wants to
transmit as an integer in its sharing records.  The application would need
to define a string converter to turn the hex string into an integer.

So let's define a ``hexint`` type that we can use in field definitions where
we want to be able to supply either integers or hex strings as input when
creating a record.

    >>> hexint = eim.IntType('cid:hexint_example@osaf.us')

    >>> class HexRecord(eim.Record):
    ...     URI = 'cid:eim.HexRecord@osaf.us'
    ...     aField = eim.field(hexint)

By default, there is no converter registered to convert strings to integers,
although there is one for converting integers to integers::

    >>> HexRecord(23)
    HexRecord(23)

    >>> HexRecord("23")
    Traceback (most recent call last):
      ...
    TypeError: No converter registered for values of type <type 'str'>

The ``eim.add_converter()`` API allows you to register a conversion
function to be used for a particular field or field type::

    >>> eim.add_converter(hexint, str, lambda v: int(v,16))
    >>> HexRecord("23")
    HexRecord(35)

You can also override the conversion function(s) on a field-by-field basis::

    >>> eim.add_converter(HexRecord.aField, str, lambda v: int(v,8))
    >>> HexRecord("23")
    HexRecord(19)

There is a default converter registered to accept a value of  None for all
types::

    >>> HexRecord(None)
    HexRecord(None)

The UUID type uses a converter to normalize UUID strings::

    >>> demo = DemoRecord2("ED0277AF-18A2-45B1-917D-A55DC75DA776:20080922T000000Z")
    >>> demo
    DemoRecord2(u'ed0277af-18a2-45b1-917d-a55dc75da776:20080922T000000Z')
    >>> DemoRecord2("ed0277af-18a2-45b1-917d-a55dc75da776:20080922T000000Z") == demo
    True

XXX Need more default encoders for primitive types; only int->IntType currently
    works


Creating Subtypes
-----------------

Sometimes, it's useful to create a field type by copying an existing type.  The
``eim.subtype()`` function creates a new type from an existing one.  The
new type will be of the same primitive type, and it will "inherit" any
conversion functions defined for the base type::

    >>> hexint2 = eim.subtype(hexint)
    >>> hexint2
    eim.IntType(None)

    >>> eim.get_converter(hexint2)("23")
    35

New subtypes default to having the same size as their base type, if
applicable, and any extra arguments to ``subtype()`` are passed through to
the appropriate constructor::

    >>> bytes1 = eim.BytesType(size=55)
    >>> bytes2 = eim.subtype(bytes1, 'bytes2 uri')
    >>> bytes2
    eim.BytesType('bytes2 uri', 55)

    >>> dec1 = eim.DecimalType(None, 9, 3)
    >>> eim.subtype(dec1, decimal_places = 2)
    eim.DecimalType(None, 9, 2)
    >>> eim.subtype(dec1, digits = 7)
    eim.DecimalType(None, 7, 3)

Note that you can also subtype type aliases::

    >>> eim.subtype(my_int, 'dummy uri')
    eim.IntType('dummy uri')


XXX test generation-skipping in converter registration


---------
Internals
---------

TypeInfo instances are immutable once created::

    >>> t = eim.IntType()
    >>> t.uri = "fhdsfblah"
    Traceback (most recent call last):
      ...
    TypeError: eim.IntType instances are immutable

Misc. constructor data validation tests::

    >>> eim.TypeInfo()
    Traceback (most recent call last):
      ...
    TypeError: eim.TypeInfo is an abstract type; use a subtype

    >>> eim.SizedType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a eim.SizedType

    >>> eim.SizedType(size=53)
    Traceback (most recent call last):
      ...
    TypeError: eim.SizedType is an abstract type; use a subtype

    >>> eim.BytesType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a eim.BytesType

    >>> eim.TextType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a eim.TextType

    >>> eim.DecimalType()
    Traceback (most recent call last):
      ...
    TypeError: digits and decimal_places must be ... eim.DecimalType

    >>> eim.DecimalType(None, 3)    # default places of 0
    eim.DecimalType(None, 3, 0)


No such type::

    >>> eim.typeinfo_for('xyz:abc')
    Traceback (most recent call last):
      ...
    UnknownType: 'xyz:abc'

Recordtype/field creation and sequence numbers::

    >>> class MyRecord(eim.Record):
    ...     URI = 'cid:eim.MyRecord@osaf.us'
    ...     f1, f2 = eim.field(hexint), eim.field(hexint)

    >>> f1, f2 = MyRecord.f1, MyRecord.f2

    >>> f1.name
    'f1'
    >>> f1.offset
    1
    >>> f2.offset
    2
    >>> f1.owner is MyRecord
    True

    >>> MyRecord.__fields__ == (f1, f2)
    True

    >>> f1.type is hexint
    True
    >>> f1 < f2
    True
    >>> f2 > f1
    True
    >>> f1 != f2
    True
    >>> f1 >= f2
    False

    >>> f2 == f2.seq    # must not be directly comparable to integer
    False

    >>> class MR2(eim.Record):
    ...     URI = 'cid:eim.MR2@osaf.us'
    ...     f3 = eim.field(my_int)

    >>> r = MyRecord("23", f2=3)
    >>> r
    MyRecord(35, 3)

    >>> r.f1, r.f2
    (35, 3)

    >>> MR2(27)
    MR2(27)

    >>> eim.field(27)   # must be a registered type or alias
    Traceback (most recent call last):
      ...
    UnknownType: 27

Verify that the generated constructor code shows up in tracebacks::

    >>> try:
    ...     MR2(42.0)
    ... except:
    ...     import traceback
    ...     tb = traceback.format_exc()

    >>> print tb
    Traceback (most recent call last):
      File ...
        MR2(42.0)
      File "EIM-Generated Constructor for __builtin__.MR2", line 2, in __new__
        f3 = get_converter(cls.f3)(f3)
      ...
    TypeError: No converter registered for values of type <type 'float'>
    <BLANKLINE>

Immutable field attrs::

    >>> eim.field(my_int).foo = "bar"
    Traceback (most recent call last):
      ...
    AttributeError: 'field' object has no attribute 'foo'

    >>> MyRecord.f1.offset = 16
    Traceback (most recent call last):
      ...
    TypeError: field objects are immutable

Record is dict-less, immutable::

    >>> r.__dict__
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object has no attribute '__dict__'

    >>> r.f1 = 42
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object attribute 'f1' is read-only

    >>> r.xxx = 99
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object has no attribute 'xxx'


Can't subclass an existing record type, or reuse fields in other record types::

    >>> class CantDoThis(MyRecord):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: Record classes cannot be subclassed

    >>> class CantDoThis(eim.Record):
    ...     URI = 'cid:eim.CantDoThis@osaf.us'
    ...     f3 = MyRecord.f1
    Traceback (most recent call last):
      ...
    TypeError: Can't reuse field 'MyRecord.f1' as 'CantDoThis.f3'

Can't filter a non-record type::

    >>> Passwords.sync_filter(42)
    Traceback (most recent call last):
      ...
    TypeError: Not a Record, RecordSet, or Diff: 42

Can't add non-field, non-filter to filter::

    >>> Passwords += 42
    Traceback (most recent call last):
      ...
    TypeError: Can't add 42 to Filter

Translators *must* have all required attributes, of the right types, and with
unique URIs::

    >>> class MissingURI(eim.Translator):
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: Translator classes must have a `URI` attribute of type `str`

    >>> class MissingVersion(eim.Translator):
    ...     URI = 'cid:foo@bar.osaf.us'
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: Translator classes must have a `version` attribute of type `int`

    >>> class MissingDescr(eim.Translator):
    ...     URI = 'cid:foo@bar.osaf.us'
    ...     version = 42
    Traceback (most recent call last):
      ...
    TypeError: ... must have a `description` attribute of type `unicode`

    >>> class DupeURI(eim.Translator):
    ...     URI = 'cid:eim.R@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:eim.R@osaf.us' is already in use

More than one import or delete type can be declared for a given function::

    >>> class Testlator1(eim.Translator):
    ...     URI = 'cid:testlator1@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.importer
    ...     @MyRecord.importer
    ...     def import_something(self, record):
    ...         print "yo!", record
    ...
    ...     @R.deleter
    ...     @MyRecord.deleter
    ...     def delete_something(self, record):
    ...         print "hasta la vista,", record

    >>> t = Testlator1()
    >>> t.startImport()
    >>> t.importRecords(eim.Diff([R(1,2)], [MyRecord(3,4)]))
    yo! R(1, 2)
    hasta la vista, MyRecord(3, 4)

    >>> t.finishImport()

But it's an error to define more than one importer, exporter, or deleter for
a given type in a given translator class::

    >>> class Testlator2(eim.Translator):
    ...     URI = 'cid:testlator2@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.importer
    ...     def import_something(self, record):
    ...         print "yo!", record
    ...
    ...     @R.importer
    ...     def extra_import(self, record):
    ...         print "howzit,", record
    Traceback (most recent call last):
      ...
    TypeError: Multiple importers defined for <class 'R'> in <class 'Testlator2'>

    >>> class Testlator3(eim.Translator):
    ...     URI = 'cid:testlator3@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.deleter
    ...     def del_something(self, record):
    ...         print "adios!", record
    ...
    ...     @R.deleter
    ...     def extra_del(self, record):
    ...         print "see ya,", record
    Traceback (most recent call last):
      ...
    TypeError: Multiple deleters defined for <class 'R'> in <class 'Testlator3'>

    >>> class Testlator4(eim.Translator):
    ...     URI = 'cid:testlator4@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @eim.exporter(Item)
    ...     def export_something(self, item):
    ...         return []
    ...
    ...     @eim.exporter(Item)
    ...     def extra_export(self, item):
    ...         return []
    Traceback (most recent call last):
      ...
    TypeError: Multiple exporters defined for <class '...Item'> in <class 'Testlator4'>

Exporters can only be registered for ``Item`` classes and ``ItemAddOn`` or ``Extension``
subclasses::

    >>> @eim.exporter(object)
    ... def wont_work(self, item):
    ...     return []
    Traceback (most recent call last):
      . . .
    TypeError: <type 'object'> is not an `Item`, `ItemAddOn` or `Extension`

    >>> @eim.exporter(Extension)    # has to be a *subclass* of Extension
    ... def wont_work(self, item):
    ...     return []
    Traceback (most recent call last):
      . . .
    TypeError: <class 'chandler.core.Extension'> is not an `Item`, `ItemAddOn` or `Extension`

Diff ``_merge()`` method should handle multiple encounters w/conflicting
records::

    >>> rs = eim.Diff([R(1,2)])
    >>> rs._merge([], [R(1,3), R(1,4)])
    >>> rs
    Diff(set([]), set([]))

    >>> rs = eim.Diff([R(1,2)])
    >>> rs._merge([R(1,3), R(1,4)], [])
    >>> rs
    Diff(set([]), set([]))

sort_records(records) will return records such that depenencies occur first::

    >>> class DemoA(eim.Record):
    ...     URI = 'cid:eim.test.demoA-record@osaf.us'
    ...     uuid  = eim.key(int)

    >>> class DemoB(eim.Record):
    ...     URI = 'cid:eim.test.demoB-record@osaf.us'
    ...     uuid  = eim.key(DemoA.uuid)

    >>> class DemoC(eim.Record):
    ...     URI = 'cid:eim.test.demoC-record@osaf.us'
    ...     uuid  = eim.key(DemoB.uuid)

    >>> class DemoD(eim.Record):
    ...     URI = 'cid:eim.test.demoD-record@osaf.us'
    ...     uuid  = eim.key(DemoC.uuid)

    >>> rA = DemoA(1)
    >>> rB = DemoB(1)
    >>> rC = DemoC(1)
    >>> rD = DemoD(1)

    >>> list(eim.sort_records( [rA, rB, rC, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rC, rD, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rD, rB, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rA, rD, rC, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rB, rD, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rC, rB, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rB, rC, rD, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rD, rA, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rA, rC, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rB, rA, rD, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rC, rA, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rD, rC, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rC, rD, rA, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rA, rB, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rB, rD, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rC, rB, rA, rD] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rD, rB, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rA, rD, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rD, rA, rB, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rB, rC, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rC, rA, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rD, rC, rB, rA] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rA, rC, rB] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rB, rA, rC] ))
    [DemoA(1), DemoB(1), DemoC(1), DemoD(1)]

    >>> list(eim.sort_records( [rA, rB, rC] ))
    [DemoA(1), DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rA, rC, rB] ))
    [DemoA(1), DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rB, rA, rC] ))
    [DemoA(1), DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rB, rC, rA] ))
    [DemoA(1), DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rC, rA, rB] ))
    [DemoA(1), DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rC, rB, rA] ))
    [DemoA(1), DemoB(1), DemoC(1)]

    >>> list(eim.sort_records( [rA, rB, rD] ))
    [DemoA(1), DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rD, rB] ))
    [DemoA(1), DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rA, rD] ))
    [DemoA(1), DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rD, rA] ))
    [DemoA(1), DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rA, rB] ))
    [DemoA(1), DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rB, rA] ))
    [DemoA(1), DemoB(1), DemoD(1)]


    >>> list(eim.sort_records( [rA, rC, rD] ))
    [DemoA(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rA, rD, rC] ))
    [DemoA(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rA, rD] ))
    [DemoA(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rD, rA] ))
    [DemoA(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rA, rC] ))
    [DemoA(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rC, rA] ))
    [DemoA(1), DemoC(1), DemoD(1)]


    >>> list(eim.sort_records( [rB, rC, rD] ))
    [DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rB, rD, rC] ))
    [DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rB, rD] ))
    [DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rC, rD, rB] ))
    [DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rB, rC] ))
    [DemoB(1), DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rC, rB] ))
    [DemoB(1), DemoC(1), DemoD(1)]


    >>> list(eim.sort_records( [rA, rB] ))
    [DemoA(1), DemoB(1)]
    >>> list(eim.sort_records( [rB, rA] ))
    [DemoA(1), DemoB(1)]

    >>> list(eim.sort_records( [rA, rC] ))
    [DemoA(1), DemoC(1)]
    >>> list(eim.sort_records( [rC, rA] ))
    [DemoA(1), DemoC(1)]

    >>> list(eim.sort_records( [rA, rD] ))
    [DemoA(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rA] ))
    [DemoA(1), DemoD(1)]

    >>> list(eim.sort_records( [rB, rC] ))
    [DemoB(1), DemoC(1)]
    >>> list(eim.sort_records( [rC, rB] ))
    [DemoB(1), DemoC(1)]

    >>> list(eim.sort_records( [rB, rD] ))
    [DemoB(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rB] ))
    [DemoB(1), DemoD(1)]

    >>> list(eim.sort_records( [rC, rD] ))
    [DemoC(1), DemoD(1)]
    >>> list(eim.sort_records( [rD, rC] ))
    [DemoC(1), DemoD(1)]


    >>> list(eim.sort_records( [rA] ))
    [DemoA(1)]
    >>> list(eim.sort_records( [rB] ))
    [DemoB(1)]
    >>> list(eim.sort_records( [rC] ))
    [DemoC(1)]
    >>> list(eim.sort_records( [rD] ))
    [DemoD(1)]

