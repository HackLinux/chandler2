Items,  and Extensions and DashboardEntries
-------------------------------------------

.. module:: chandler.core

Items
~~~~~

At the core of the Chandler data model is the :class:`Item` class:

>>> from chandler.core import *
>>> item = Item()

Every item has a :attr:`~Item.title`:

>>> item.title
u''

and, of course, you may supply your own :attr:`~Item.title` at initialization time:

>>> Item(title=u'Hello, world!').title
u'Hello, world!'

or after initialization:

>>> item.title = u'No!'
>>> item.title
u'No!'

Items also automatically have a :attr:`~Item.created` timestamp cell.
To test it, we'll pretend it's 10AM.

>>> from chandler.time_services import *
>>> from peak.events.activity import Time
>>> from datetime import datetime
>>> setNow(datetime(2008, 10, 1, 10, tzinfo=TimeZone.pacific))
>>> ten_am = nowTimestamp()
>>> item = Item()

To make sure the :attr:`~Item.created` cell is immediately set,
we'll advance time by an hour before checking its value.

>>> Time.advance(3600.0)
>>> item.created
1222880400.0
>>> item.created == ten_am
True

Extensions
~~~~~~~~~~

Of course, a titled object is not particularly interesting. Items support
having sets of ``extensions`` installed. These extensions can be used to
customize object attributes and behaviour (in fact, for reasons of
extensibility, subclassing item is not recommended).

An item starts out with no extensions installed:

>>> list(item.extensions)
[]

Note that once you have an Extension, you can't change its item.

>>> e = Extension(item)
>>> #e.item = Item() # @@@ should raise, but doesn't!
>>> e.item is item
True

Note that Extension objects, which use the ``peak.util.addons`` library, are
uniqued:

>>> Extension(item) is e
True

Merely instantiating an extension on an item does not add it to the item’s
set of extensions. So, in our current example:

>>> e in item.extensions
False

However, if we call the ``add()`` method, then our extension does get added:

>>> e.add()
<chandler.core.Extension object at 0x...>
>>> e in item.extensions
True

Note that the extension object itself is returned from ``add()``; this is
for convenience in setting up and installing extensions.

You can’t add an extension that has already been added:

>>> e.add()
Traceback (most recent call last):
...
ValueError: Extension <class 'chandler.core.Extension'> has already been added

However, you can use the ``remove()`` method to remove an existing extension:

>>> e.remove()
>>> e in item.extensions
False

As you might expect from the ``add()`` case above, it is an error to try to
``remove()`` an extension that isn’t there:

>>> e.remove()
Traceback (most recent call last):
...
ValueError: Extension <class 'chandler.core.Extension'> is not present

Subclassing Extension
~~~~~~~~~~~~~~~~~~~~~

When you extend ``Item``, you typically want to add attributes or method.
The way to do this is to subclass ``Extension``:

>>> import peak.events.trellis as trellis
>>> class MyExtension(Extension):
...     can_this_be_true = trellis.attr(False)

>>> my_ext = MyExtension(item)

As usual, your subclass does not start off in the ``extensions`` for the
given Item:

>>> my_ext in item.extensions
False

This is true even if the superclass has been added:

>>> Extension(item).add() in item.extensions
True
>>> my_ext in item.extensions
False

There is also a convenience class method for testing if a given extension
class has been installed on an item. So, the last two tests of
``item.extensions`` can be rephrased as:

>>> Extension.installed_on(item)
True
>>> MyExtension.installed_on(item)
False

The ``installed_on`` method also works on an arbitrary Extension object:

>>> another_extension = MyExtension(Item()).add()
>>> MyExtension.installed_on(another_extension)
True
>>> Extension.installed_on(another_extension)
False

Initializing attributes when adding an extension
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``add()`` method takes keywords, so you can set up attributes when you
add extensions to an item:

>>> new_my_ext = MyExtension(Item()).add(can_this_be_true=True)
>>> new_my_ext.can_this_be_true
True


.. index:: hook; chandler.domain.item_addon (used by chandler.core)

Adding attributes to all Items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Extensions are optional.  Some items will have a given Extension added,
others won't.

If an addition to Item should apply to all items, instead of using an
Extension, create an AddOn class.  The class can be automatically
added to items when they're initialized by registering the class using
the *chandler.domain.item_addon* hook.

>>> from peak.util import plugins
>>> addon_hook = plugins.Hook('chandler.domain.item_addon')
>>> def item_initialized(item):
...     print "Item initialized!"
>>> addon_hook.register(item_initialized)
>>> new_item = Item()
Item initialized!

